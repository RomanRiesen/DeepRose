function Turn(){this.cardIndex=NaN;this.playKnight=false;this.tookCard=false;this.hasToPass=false}
function Dna(k0,k1,k2,k3,tc0,tc1,tc2,tc3){this.playKnightScoreValues=[k0,k1,k2,k3];this.drawCardScoreValues=[tc0,tc1,tc2,tc3];this.drawCardPolynom=new Polynomial(3,this.drawCardScoreValues);this.playKnightPolynom=new Polynomial(3,this.playKnightScoreValues);this.drawCardScore=function(x){x=x===undefined?board.remainingStones:x;return this.drawCardPolynom.valueAt(x)};this.playKnightScore=function(x){x=x===undefined?board.remainingStones:x;return this.playKnightPolynom.valueAt(x)};this.maxMutation=
[30,10,.6,.2,10,2,.5,.25];this.mutate=function(){var c=0;for(var i=0;i<this.playKnightScoreValues.length;i++,c++)this.playKnightScoreValues[i]+=Math.random()*this.maxMutation[c]-Math.random()*this.maxMutation[c];for(var i=0;i<this.drawCardScoreValues.length;i++,c++)this.drawCardScoreValues[i]+=Math.random()*this.maxMutation[c]-Math.random()*this.maxMutation[c];console.log(this.drawCardScoreValues)}}
function Node(v){v=v===undefined?null:v;this.parentNode=null;this.value=v;this.childNodes=[];this.addChild=function(c){n=new Node(c);this.childNodes.push(n);return n}}
function AI(player,oponent,depth){this.player=player;this.startPlayer=player;this.oponent=oponent;this.depth=depth;this.treeNode=new Node;this.notAbleToPlayPenalty=-50;this.dna=new Dna(-55,0,.008,0,2,0,0,0);this.__getScore=function(board,player,oponent){return player.countScore(board)-oponent.countScore(board)};this.drawCardTurn=function(){var turn=new Turn;var playerCopy=player.copy();var boardCopy=board.copy();var deckCopy=deck.copy();turn.tookCard=true;turn.score=this.__getScore(boardCopy,playerCopy,
oponent.copy())+this.dna.drawCardScore();return turn};this.playCardTurn=function(index){var turn=new Turn;var playerCopy=player.copy();var boardCopy=board.copy();var deckCopy=deck.copy();turn.cardIndex=index;turn.playKnight=false;playerCopy.playCard(turn.cardIndex,boardCopy,deckCopy,turn.playKnight,true);turn.score=this.__getScore(boardCopy,playerCopy,oponent.copy());return turn};this.playKnightTurn=function(index){var turn=new Turn;var playerCopy=player.copy();var boardCopy=board.copy();var deckCopy=
deck.copy();turn.cardIndex=index;turn.playKnight=true;playerCopy.playCard(turn.cardIndex,boardCopy,deckCopy,true,true);var scoreDif=this.__getScore(boardCopy,playerCopy,oponent.copy());turn.score=scoreDif+this.dna.playKnightScore()-playerCopy.countScore(boardCopy)*.25;console.log("Knight has a value of "+turn.score+" for the ai.");return turn};this.listAllTurns=function(board,deck,player,oponent){player=player===undefined?this.player:player;oponent=oponent===undefined?this.oponent:oponent;var obj=
player.checkPossibleMoves(board,deck);var state=obj.state;var playableIndices=obj.playableIndices;var knightIndices=obj.playableWithKnightIndices;var turns=[];switch(state){case "hasToPlayKnightOrTakeCard":turn=this.drawCardTurn();turns.push(turn);for(var i=0;i<knightIndices.length;i++){turn=this.playKnightTurn(knightIndices[i]);turns.push(turn)}break;case "hasToTakeCard":turn=this.drawCardTurn();turns.push(turn);break;case "hasToPlayKnight":for(var i=0;i<knightIndices.length;i++){turn=this.playKnightTurn(knightIndices[i]);
turns.push(turn)}break;case "isAbleToPlayNormally":turn=this.drawCardTurn();turns.push(turn);for(var i=0;i<playableIndices.length;i++){turn=this.playCardTurn(playableIndices[i]);turns.push(turn)}for(var i=0;i<knightIndices.length;i++){turn=this.playKnightTurn(knightIndices[i]);turns.push(turn)}break;case "isAbleToPlayCardButNotKnight":turn=this.drawCardTurn();turns.push(turn);for(var i=0;i<playableIndices.length;i++){turn=this.playCardTurn(playableIndices[i]);turns.push(turn)}break;case "noPossibleTurnLeft":var turn=
new Turn;var playerCopy=player.copy();var boardCopy=board.copy();var deckCopy=deck.copy();if(board.gameHasEnded(playerCopy,oponent,deck)){playerScore=playerCopy.countScore(board);oponentScore=oponent.countScore(board);if(playerScore>oponentScore)turn.score=1/0;else turn.score=-1/0}else{turn.score=playerCopy.countScore(board)+this.notAbleToPlayPenalty;turn.hasToPass=true}turns.push(turn);break}if(player.copy().addCard(deck.copy())!==true)for(var i=turns.length-1;i>=0;i--)if(turn===undefined||turns[i].tookCard===
true)turns.splice(i,1);if(player.knightCount<1)for(var i=turns.length-1;i>=0;i--)if(turns[i].playKnight===true){turns.splice(i,1);console.log("Knight Turn removed")}return turns};this.createStrategyTree=function(board,deck,player,oponent,node,depth,currDepth,startNode,turns){player=player===undefined?this.player:player;oponent=oponent===undefined?this.oponent:oponent;node=node===undefined?new Node(null):node;depth=depth===undefined?10:depth;currDepth=currDepth===undefined?0:currDepth;startNode=startNode===
undefined?new Node(null):startNode;if(depth==currDepth)return node;if(turns===undefined)node=startNode;var turns=this.listAllTurns(board,deck,this.player,this.oponent);for(var i=0;i<turns.length;i++){board2=board.copy();deck2=deck.copy();oponent2=oponent.copy();player2=player.copy();this.player.playTurn(turns[i],board2,deck2);console.log(player.cards[0]==player2.cards[0]);var n=this.createStrategyTree(board2,deck2,oponent2,player2,node.addChild(turns[i]),depth,currDepth+1,startNode,turns);console.log(n.value)}return startNode};
this.findBestPathInTree=function(tree){};this.calculateBestTurnViaTree=function(baord,deck,depth){this.createStrategyTree(board,deck,this.player,this.oponent,node=new Node(null),depth=1);return best};this.takeRandomTurn=function(board,deck){var playableIndices=this.player.checkPossibleMoves(board,deck).playableIndices;if(playableIndices.length===0){var wasAbleToDrawCard=this.player.addCard(deck)===true;if(!wasAbleToDrawCard)return"hasToPass"}var c=Math.random();if(c<.7)if(!(this.player.addCard(deck)===
true))return true;v=!(this.player.playCard(chooseFromArray(playableIndices),board,deck)===true);return true};this.playBestNextTurn=function(board,deck){bestTurn=new Turn;bestTurn.score=-1/0;turns=this.listAllTurns(board,deck);for(var i=0;i<turns.length;i++)if(bestTurn.score<=turns[i].score)bestTurn=turns[i];if(bestTurn.hasToPass)return;if(bestTurn.tookCard===true){this.player.addCard(deck);return}this.player.playCard(bestTurn.cardIndex,board,deck,bestTurn.playKnight,true)}}
function chooseFromArray(arr){i=Math.floor(Math.random()*arr.length);return arr[i]};

